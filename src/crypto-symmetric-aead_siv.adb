-- This program is free software; you can redistribute it and/or
-- modify it under the terms of the GNU General Public License as
-- published by the Free Software Foundation; either version 2 of the
-- License, or (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-- General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-- 02111-1307, USA.

-- As a special exception, if other files instantiate generics from
-- this unit, or you link this unit with other files to produce an
-- executable, this unit does not by itself cause the resulting
-- executable to be covered by the GNU General Public License. This
-- exception does not however invalidate any other reasons why the
-- executable file might be covered by the GNU Public License.

with Crypto.Symmetric.Mac.CMAC;
with Crypto.Symmetric.Mode.CTR;
with Crypto.Symmetric.Oneway_Blockcipher;
with Ada.Containers.Indefinite_Vectors;

package body Crypto.Symmetric.AEAD_SIV is

   -- useful constants
   Bytes_Per_Block : constant Positive := Block'Size / 8;
   Bytes_Per_Key_Block : constant Positive := Key_Type'Size / 8;
   Zero_Bytes: constant Bytes(0..(Bytes_Per_Block - 1)) := (others => 0);
   Zero_Block: constant Block := To_Block_Type(Zero_Bytes);

   -- package initializations
   package BC_Oneway is new Crypto.Symmetric.Oneway_Blockcipher(Block          => BC.Block,
                                                                Key_Type       => BC.Key_Type,
                                                                Cipherkey_Type => BC.Cipherkey_Type,
                                                                Prepare_Key    => BC.Prepare_Key,
                                                                Encrypt        => BC.Encrypt);

   package CMAC is new Crypto.Symmetric.Mac.CMAC(C          => BC_Oneway,
                                                 "xor"      => "xor");

   package CTR is new Crypto.Symmetric.Mode.CTR(BC);

   package Vectors is new Ada.Containers.Indefinite_Vectors(Index_Type   => Positive,  -- Used to store the whole plaintext
                                                            Element_Type => Bytes);    -- block by block.

   -----------------------------------------------------------------
   ----
   ---- auxiliary functions and procedures
   ----
   -----------------------------------------------------------------

   -- This procedure calaculates the IV for the CTR-Mode
   -- IV <-- IV & [ 1^(n-64) 01^(31) 01^(31) ]
   procedure Prepare_IV (IV: in out Block) is
      Temp: Bytes(0..Block'Size / 8 - 1) := (others => 16#FF#);
   begin
      Temp(Temp'Last-3) := 16#7F#;
      Temp(Temp'Last-7) := 16#7F#;
      IV := To_Block_Type(To_Bytes(IV) & Temp);
   end Prepare_IV;

   -----------------------------------------------------------------

   -- This procedure is doubling the value Result considering
   -- a specially condition based on irreducible polynomials (see paper).
   procedure DBL (B : in out Block) is
      Bytes_Per_Block: constant Positive := Block'Size/8;
      Byte_Array: constant Bytes := To_Bytes(B);
   begin
      if Bytes_Per_Block = 16 then
         if (Byte_Array(Byte_Array'First) and 16#80#) = 0 then
            B := Shift_Left(B,1);
         else
            declare
               Const: Bytes(0..Bytes_Per_Block-1) := (others => 0);
            begin
               Const(Const'Last) := 16#87#;
               B := Shift_Left(B,1) xor To_Block_Type(Const);
            end;
         end if;
      else
         B := Shift_Left(B,1);
      end if;
   end DBL;

   -----------------------------------------------------------------

   -- This function generates the second key K2 (for CTR-Mode) according to
   -- the specified key K1 (used for the Blockcipher).
   -- The second key is generated by:
   -- K2 = first k bits(E_K1(0^n)) || first k bits (E_K1(1^n)), in which
   -- n is the size of one message block in bits and k is Bytes_Per_Key_Block / 2.
   -- Redundant bits are truncated. The Key must not be greater than
   -- 2 * Bytes_Per_Block.
   function Generate_Key return Key_Type is
      Temp: Bytes := Zero_Bytes;
      Left, Right: Block;
      Key: Bytes(0..Bytes_Per_Key_Block-1);
   begin
      if Bytes_Per_Key_Block > (Bytes_Per_Block * 2) then
         raise Invalid_Key_Length;
      else

         Encrypt(To_Block_Type(Temp), Left);
         Temp := (others => 16#FF#);
         Encrypt(To_Block_Type(Temp), Right);
         Temp := To_Bytes(Left);
         Key(Key'First..(Bytes_Per_Key_Block/2)-1)           := Temp(Temp'First..(Bytes_Per_Key_Block/2)-1);
         Temp := To_Bytes(Right);
         Key((Bytes_Per_Key_Block/2)..Bytes_Per_Key_Block-1) := Temp(Temp'First..(Bytes_Per_Key_Block/2)-1);
      end if;

      return BC.To_Key_Type(Key);
   end Generate_Key;

   -----------------------------------------------------------------

   procedure Padding(B        : in out Bytes;
                     Position : in     Natural) is
   begin
      B(Position..B'Last) := (others => 0);
      B(Position) := 16#80#;
   end Padding;

   -----------------------------------------------------------------

   -- This procedure decrypt and write each Ciphertext block. It won't
   -- be called, if the calculated IV isn't the same as the specified.
   procedure Write_Decrypted_Plaintext(This                  : in AEAD_SIV;
                                       Read_Ciphertext_Again : in Callback_Reader;
                                       Write_Plaintext       : in Callback_Writer) is
      Bytes_Read: Natural;
      IV: Block;

      Plaintext: Block;
      Ciphertext: Bytes(Zero_Bytes'Range);
   begin
      Read_Ciphertext_Again(Ciphertext, Bytes_Read);
      IV := To_Block(Ciphertext);
      Prepare_IV(IV);
      CTR.Init(This.CTR_Key, IV);

      loop
         Read_Ciphertext_Again(Ciphertext, Bytes_Read);
         if Bytes_Read = Bytes_Per_Block then
            CTR.Decrypt(To_Block(Ciphertext), Plaintext);
            Write_Plaintext(To_Bytes(Plaintext));
         elsif Bytes_Read = 0 then
            exit;
         else
            CTR.Decrypt(To_Block(Ciphertext), Plaintext);
            Write_Plaintext(To_Bytes(Plaintext)(0..Bytes_Read-1));
            exit;
         end if;
      end loop;
   end Write_Decrypted_Plaintext;

   -----------------------------------------------------------------

   -- This procedure is called by the Init-procedures. It calculates
   -- the first CMAC value CMAC_K1(0) and doubled it.
   procedure Aux_Init(This  : in out AEAD_SIV;
                      Nonce : in     Block) is
      Tmp: Block;
   begin
      CMAC.Final_Sign(Final_Message_Block => Zero_Block,
                      Bytes_Read          => Bytes_Per_Block,
                      Tag                 => This.Result);

      DBL(This.Result);

      CMAC.Final_Sign(Final_Message_Block => Nonce,
                      Bytes_Read          => Bytes_Per_Block,
                      Tag                 => Tmp);

      This.Result := This.Result xor Tmp;
      DBL(This.Result);
   end Aux_Init;

   -----------------------------------------------------------------

   -- This procedure reads in the whole Header, signed each block
   -- and updates the value Result
   procedure Aux_Header(Result      : in out Block;
                        Read_Header : in     Callback_Reader) is
      Bytes_Read: Natural;
      Tag: Block;
      Prev_Header: Bytes := Zero_Bytes;
      Curr_Header: Bytes := Zero_Bytes;
      Final_Block: Boolean := False;
   begin
      loop
         Read_Header(Curr_Header, Bytes_Read);
         Prev_Header := Curr_Header;

         if Bytes_Read = Bytes_Per_Block then
            Read_Header(Curr_Header, Bytes_Read);

            if Bytes_Read = Bytes_Per_Block then
               CMAC.Sign(To_Block(Curr_Header));
               CMAC.Sign(To_Block(Prev_Header));
            elsif Bytes_Read = 0 then
               -- Prev_Block was the last block and filled up,
               -- so perform Final_Sign without padding
               Bytes_Read := Bytes_Per_Block;
               Final_Block := True;
            else
               CMAC.Sign(To_Block(Prev_Header));
               Prev_Header := Curr_Header;
               Final_Block := True;
            end if;
         else
            Final_Block := True;
         end if;

         if Final_Block then
            CMAC.Final_Sign(Final_Message_Block => To_Block(Prev_Header),
                            Bytes_Read          => Bytes_Read,
                            Tag                 => Tag);

            Result := Result xor Tag;
            exit;
         end if;
      end loop;
   end Aux_Header;

   -----------------------------------------------------------------

   procedure Aux_Enc(This             : in AEAD_SIV;
                     R                : in Block;
                     Read_Plaintext   : in Callback_Reader;
                     Write_Ciphertext : in Callback_Writer) is

      Bytes_Read: Natural;
      Last_B_Bytelen: Natural := Bytes_Per_Block;

      Entire_Plaintext: Vectors.Vector;
      Plaintext_Length : Positive;

      Result: Block := R;
      IV: Block;
      Last_P_Block: Block;

      Prev_Block: Bytes := Zero_Bytes;
      Curr_Block: Bytes := Zero_Bytes;
   begin

      --------------------
      -- Read Plaintext --
      -- Perform CMAC   --
      --------------------

      -- read the first block
      Read_Plaintext(Prev_Block, Bytes_Read);

      if Bytes_Read = Bytes_Per_Block then
         loop
            -- read the next block
            Read_Plaintext(Curr_Block, Bytes_Read);

            if Bytes_Read = Bytes_Per_Block then
               Entire_Plaintext.Append(Prev_Block);
               CMAC.Sign(To_Block(Prev_Block));
               Prev_Block := Curr_Block;
            elsif Bytes_Read = 0 then
               -- append final block without padding
               Entire_Plaintext.Append(Prev_Block);
               -- last readed block was the final block and filled up
               Bytes_Read := Bytes_Per_Block;

               Last_B_Bytelen := Bytes_Per_Block;
               exit;
            else
               Entire_Plaintext.Append(Prev_Block);
               CMAC.Sign(To_Block(Prev_Block));
               Prev_Block := Curr_Block;

               Last_B_Bytelen := Bytes_Read;
               exit;
            end if;
         end loop;
      else
         Last_B_Bytelen := Bytes_Read; -- |M| = 0 is allowed
      end if;

      -- padd the last block if necessary
      if Bytes_Read < Bytes_Per_Block then
         -- append final block without padding to Entire_Plaintext
         Entire_Plaintext.Append(Prev_Block);
         Padding(Prev_Block, Bytes_Read);
         DBL(Result);
      end if;

      Last_P_Block := To_Block(Prev_Block);
      Result := Result xor Last_P_Block;

      Plaintext_Length := Positive(Entire_Plaintext.Length); -- number of blocks to encrypt
      CMAC.Final_Sign(Result, Bytes_Per_Block, IV);          -- last block is always full filled (because padding)
      Write_Ciphertext(To_Bytes(IV));

      --------------
      -- CTR-Mode --
      --------------

      declare
         Output: Block;
      begin
         -- perform speciall settings for IV
         Prepare_IV(IV);

         CTR.Init(Key           => This.CTR_Key,
                  Initial_Value => IV);

         -- encrypt and write plaintext blocks, expect the last one
         for I in 1..Plaintext_Length-1 loop
            CTR.Encrypt(Plaintext  => To_Block(Entire_Plaintext.Element(I)),
                        Ciphertext => Output);
            Write_Ciphertext(To_Bytes(Output));
         end loop;

         -- encrypt and write the last (final) plaintext block
         CTR.Encrypt(Plaintext  => To_Block(Entire_Plaintext.Last_Element),
                     Ciphertext => Output);
         Prev_Block := To_Bytes(Output);
         Write_Ciphertext(Prev_Block(Prev_Block'First..Last_B_Bytelen-1));

      end;
   end Aux_Enc;

   -----------------------------------------------------------------

   function Aux_Dec(This                  : in AEAD_SIV;
                    R                     : in Block;
                    Read_Ciphertext       : in Callback_Reader;
                    Read_Ciphertext_Again : in Callback_Reader;
                    Write_Plaintext       : in Callback_Writer;
                    Store_Internally      : in Boolean) return Boolean is

      Bytes_Read: Natural;
      Entire_Plaintext: Vectors.Vector;

      Result: Block := R;
      Final_IV, IV: Block;
      Verification_Bool: Boolean;

      Plaintext: Block := Zero_Block;
      Prev_Block: Bytes := Zero_Bytes;
      Curr_Block: Bytes := Zero_Bytes;
   begin

      Read_Ciphertext(Prev_Block, Bytes_Read);
      Final_IV := To_Block(Prev_Block);

      IV := To_Block(Prev_Block);

      Prepare_IV(IV);

      CTR.Init(Key           => This.CTR_Key,
               Initial_Value => IV);

      -- apply CTR and CMAC in combination:
      Read_Ciphertext(Prev_Block, Bytes_Read);

      if Bytes_Read = 0 then
         -- |M| = 0
         null;
      elsif Bytes_Read < Bytes_Per_Block then
         CTR.Decrypt(To_Block(Prev_Block), Plaintext);
      else
         loop
            Read_Ciphertext(Curr_Block, Bytes_Read);

            if Bytes_Read = Bytes_Per_Block then
               CTR.Decrypt(To_Block(Prev_Block), Plaintext);
               if Store_Internally then
                  Entire_Plaintext.Append(To_Bytes(Plaintext));
               end if;
               CMAC.Verify(Plaintext);
               Prev_Block := Curr_Block;
            elsif Bytes_Read = 0 then
               -- Prev_Block is the last Ciphertext block
               CTR.Decrypt(To_Block(Prev_Block), Plaintext);
               -- the last block must not be padded
               Bytes_Read := Bytes_Per_Block;
               exit;
            else
               CTR.Decrypt(To_Block(Curr_Block), Plaintext);
               exit;
            end if;
         end loop;
      end if;

      -- handle the last block and padding
      declare
         Last_P_Block: Bytes(0..Bytes_Per_Block-1) := To_Bytes(Plaintext);
      begin
         if Store_Internally then
            Entire_Plaintext.Append(Last_P_Block(Last_P_Block'First..Bytes_Read-1));
         end if;
         if Bytes_Read < Bytes_Per_Block then
            Padding(Last_P_Block, Bytes_Read);
            DBL(Result);
         end if;

         Result := Result xor To_Block_Type(Last_P_Block);
         Verification_Bool := CMAC.Final_Verify(Result, Bytes_Per_Block, Final_IV);
      end;

      if Verification_Bool then
         -- write out the plaintext
         if Store_Internally then
            for I in 1..Natural(Entire_Plaintext.Length) loop
               Write_Plaintext(Entire_Plaintext.Element(I));
            end loop;
         else
            Write_Decrypted_Plaintext(This                  => This,
                                      Read_Ciphertext_Again => Read_Ciphertext_Again,
                                      Write_Plaintext       => Write_Plaintext);
         end if;
      end if;

      return Verification_Bool;

   end Aux_Dec;

   -----------------------------------------------------------------
   ----
   ---- overriding functions and procedures
   ----
   -----------------------------------------------------------------

   procedure Init_Encrypt(This   : out    AEAD_SIV;
                          Key    : in     Key_Type;
                          Nonce  : in out N.Nonce'Class) is
   begin
      CMAC.Init(Key);
      Prepare_Key(Key);
      This.CTR_Key := Generate_Key;

      Aux_Init(This, Nonce.Update);

   end Init_Encrypt;

   -----------------------------------------------------------------

   procedure Init_Decrypt(This        : out AEAD_SIV;
                          Key         : in  Key_Type;
                          Nonce_Value : in  Block) is
   begin
      CMAC.Init(Key);
      Prepare_Key(Key);
      This.CTR_Key := Generate_Key;

      Aux_Init(This, Nonce_Value);

   end Init_Decrypt;

   -----------------------------------------------------------------

   procedure Encrypt(This             : in out AEAD_SIV;
                     Read_Plaintext   : in     Callback_Reader;
                     Write_Ciphertext : in     Callback_Writer) is

   begin
      Aux_Enc(This, This.Result, Read_Plaintext, Write_Ciphertext);
   end Encrypt;

   -----------------------------------------------------------------

   procedure Encrypt(This             : in out AEAD_SIV;
                     Read_Header      : in     Callback_Reader;
                     Read_Plaintext   : in     Callback_Reader;
                     Write_Ciphertext : in     Callback_Writer) is

      Result: Block := This.Result;
   begin

      -- handle the Header
      Aux_Header(Result, Read_Header);

      Aux_Enc(This, Result, Read_Plaintext, Write_Ciphertext);

   end Encrypt;

   -----------------------------------------------------------------

   function Decrypt_And_Verify(This                   : in out AEAD_SIV;
                               Read_Ciphertext        : in     Callback_Reader;
                               Read_Ciphertext_Again  : in     Callback_Reader := null;
                               Write_Plaintext        : in     Callback_Writer)
                               return Boolean is
   begin
      if Read_Ciphertext_Again = null then
         return Aux_Dec(This                  => This,
                        R                     => This.Result,
                        Read_Ciphertext       => Read_Ciphertext,
                        Read_Ciphertext_Again => Read_Ciphertext_Again,
                        Write_Plaintext       => Write_Plaintext,
                        Store_Internally      => True);
      else
         return Aux_Dec(This                  => This,
                        R                     => This.Result,
                        Read_Ciphertext       => Read_Ciphertext,
                        Read_Ciphertext_Again => Read_Ciphertext_Again,
                        Write_Plaintext       => Write_Plaintext,
                        Store_Internally      => False);
      end if;
   end Decrypt_And_Verify;

   -----------------------------------------------------------------

   function Decrypt_And_Verify(This                   : in out AEAD_SIV;
                               Read_Header            : in     Callback_Reader;
                               Read_Ciphertext        : in     Callback_Reader;
                               Read_Ciphertext_Again  : in     Callback_Reader := null;
                               Write_Plaintext        : in     Callback_Writer)
                               return Boolean is

      Result: Block := This.Result;
   begin
      -- handle the Header
      Aux_Header(Result, Read_Header);

      if Read_Ciphertext_Again = null then
         return Aux_Dec(This                  => This,
                        R                     => Result,
                        Read_Ciphertext       => Read_Ciphertext,
                        Read_Ciphertext_Again => Read_Ciphertext_Again,
                        Write_Plaintext       => Write_Plaintext,
                        Store_Internally      => True);
      else
         return Aux_Dec(This                  => This,
                        R                     => Result,
                        Read_Ciphertext       => Read_Ciphertext,
                        Read_Ciphertext_Again => Read_Ciphertext_Again,
                        Write_Plaintext       => Write_Plaintext,
                        Store_Internally => False);
      end if;
   end Decrypt_And_Verify;

   -----------------------------------------------------------------

end Crypto.Symmetric.AEAD_SIV;
